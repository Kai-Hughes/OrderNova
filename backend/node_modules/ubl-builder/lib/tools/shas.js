"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SHA512 = exports.SHA1 = exports.SHA384 = exports.SHA256 = void 0;
var crypto = require("crypto");
/* tslint:disable:max-classes-per-file */
var SHA256 = /** @class */ (function () {
    function SHA256() {
    }
    /**
     *
     * @param content string to hash
     * @param inputEncoding input encoding "utf8" | "base64" | "binary" | "hex"
     * @param outputEncoding output "utf8" | "base64" | "binary" | "hex"
     */
    SHA256.prototype.getHash = function (content, inputEncoding, outputEncoding) {
        if (inputEncoding === void 0) { inputEncoding = 'utf8'; }
        if (outputEncoding === void 0) { outputEncoding = 'base64'; }
        var shasum = crypto.createHash('sha256');
        shasum.update(content, inputEncoding);
        var res = shasum.digest(outputEncoding);
        return res;
    };
    SHA256.prototype.getAlgorithmName = function () {
        return 'http://www.w3.org/2001/04/xmlenc#sha256';
    };
    return SHA256;
}());
exports.SHA256 = SHA256;
var SHA384 = /** @class */ (function () {
    function SHA384() {
    }
    /**
     *
     * @param content string to hash
     * @param inputEncoding input encoding "utf8" | "base64" | "binary" | "hex"
     * @param outputEncoding output encoding "utf8" | "base64" | "binary" | "hex"
     */
    SHA384.prototype.getHash = function (content, inputEncoding, outputEncoding) {
        if (inputEncoding === void 0) { inputEncoding = 'utf8'; }
        if (outputEncoding === void 0) { outputEncoding = 'hex'; }
        var shasum = crypto.createHash('SHA384');
        shasum.update(content, inputEncoding);
        var res = shasum.digest(outputEncoding);
        return res;
    };
    SHA384.prototype.getAlgorithmName = function () {
        return 'http://www.w3.org/2001/04/xmlenc#sha256';
    };
    return SHA384;
}());
exports.SHA384 = SHA384;
var SHA1 = /** @class */ (function () {
    function SHA1() {
    }
    /**
     *
     * @param content string to hash
     * @param inputEncoding input encoding "utf8" | "base64" | "binary" | "hex"
     * @param outputEncoding output encoding "utf8" | "base64" | "binary" | "hex"
     */
    SHA1.prototype.getHash = function (content, inputEncoding, outputEncoding) {
        if (inputEncoding === void 0) { inputEncoding = 'utf8'; }
        if (outputEncoding === void 0) { outputEncoding = 'base64'; }
        var shasum = crypto.createHash('sha1');
        shasum.update(content, inputEncoding);
        var res = shasum.digest(outputEncoding);
        return res;
    };
    SHA1.prototype.getAlgorithmName = function () {
        return 'http://www.w3.org/2000/09/xmldsig#sha1';
    };
    return SHA1;
}());
exports.SHA1 = SHA1;
var SHA512 = /** @class */ (function () {
    function SHA512() {
    }
    /**
     *
     * @param content string to hash
     * @param inputEncoding input encoding "utf8" | "base64" | "binary" | "hex"
     * @param outputEncoding output encoding "utf8" | "base64" | "binary" | "hex"
     */
    SHA512.prototype.getHash = function (content, inputEncoding, outputEncoding) {
        if (inputEncoding === void 0) { inputEncoding = 'utf8'; }
        if (outputEncoding === void 0) { outputEncoding = 'base64'; }
        var shasum = crypto.createHash('sha512');
        shasum.update(content, inputEncoding);
        var res = shasum.digest(outputEncoding);
        return res;
    };
    SHA512.prototype.getAlgorithmName = function () {
        return 'http://www.w3.org/2001/04/xmlenc#sha512';
    };
    return SHA512;
}());
exports.SHA512 = SHA512;
// /**
//  * Signature algorithm implementation
//  *
//  */
// function RSASHA1() {
//   /**
//   * Sign the given string using the given key
//   *
//   */
//   this.getSignature = function(signedInfo, signingKey) {
//     var signer = crypto.createSign("RSA-SHA1")
//     signer.update(signedInfo)
//     var res = signer.sign(signingKey, 'base64')
//     return res
//   }
//   /**
//   * Verify the given signature of the given string using key
//   *
//   */
//   this.verifySignature = function(str, key, signatureValue) {
//     var verifier = crypto.createVerify("RSA-SHA1")
//     verifier.update(str)
//     var res = verifier.verify(key, signatureValue, 'base64')
//     return res
//   }
//   this.getAlgorithmName = function() {
//     return "http://www.w3.org/2000/09/xmldsig#rsa-sha1"
//   }
// }
// /**
//  * Signature algorithm implementation
//  *
//  */
// function RSASHA256() {
//   /**
//   * Sign the given string using the given key
//   *
//   */
//   this.getSignature = function(signedInfo, signingKey) {
//     var signer = crypto.createSign("RSA-SHA256")
//     signer.update(signedInfo)
//     var res = signer.sign(signingKey, 'base64')
//     return res
//   }
//   /**
//   * Verify the given signature of the given string using key
//   *
//   */
//   this.verifySignature = function(str, key, signatureValue) {
//     var verifier = crypto.createVerify("RSA-SHA256")
//     verifier.update(str)
//     var res = verifier.verify(key, signatureValue, 'base64')
//     return res
//   }
//   this.getAlgorithmName = function() {
//     return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha256"
//   }
// }
// /**
//  * Signature algorithm implementation
//  *
//  */
// function RSASHA512() {
//   /**
//   * Sign the given string using the given key
//   *
//   */
//   this.getSignature = function(signedInfo, signingKey) {
//     var signer = crypto.createSign("RSA-SHA512")
//     signer.update(signedInfo)
//     var res = signer.sign(signingKey, 'base64')
//     return res
//   }
//   /**
//   * Verify the given signature of the given string using key
//   *
//   */
//   this.verifySignature = function(str, key, signatureValue) {
//     var verifier = crypto.createVerify("RSA-SHA512")
//     verifier.update(str)
//     var res = verifier.verify(key, signatureValue, 'base64')
//     return res
//   }
//   this.getAlgorithmName = function() {
//     return "http://www.w3.org/2001/04/xmldsig-more#rsa-sha512"
//   }
// }
// function HMACSHA1() {
//     this.verifySignature = function(str, key, signatureValue) {
//         var verifier = crypto.createHmac("SHA1", key);
//         verifier.update(str);
//         var res = verifier.digest('base64');
//         return res === signatureValue;
//     };
//     this.getAlgorithmName = function() {
//         return "http://www.w3.org/2000/09/xmldsig#hmac-sha1";
//     };
//     this.getSignature = function(signedInfo, signingKey) {
//         var verifier = crypto.createHmac("SHA1", signingKey);
//         verifier.update(signedInfo);
//         var res = verifier.digest('base64');
//         return res;
//     };
// }
