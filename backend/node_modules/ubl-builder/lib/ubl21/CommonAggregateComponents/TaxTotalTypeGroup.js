"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.WithholdingTaxTotal = exports.TaxTotal = void 0;
var GenericAggregateComponent_1 = require("./GenericAggregateComponent");
var UdtAmount_1 = require("../types/UnqualifiedDataTypes/UdtAmount");
var UnqualifiedDataTypes_1 = require("../types/UnqualifiedDataTypes");
var TaxSubtotal_1 = require("./TaxSubtotal");
/*

  1  cbc:TaxAmount [1..1]    The total tax amount for a particular taxation scheme, e.g., VAT; the sum of the tax subtotals for each tax category within the taxation scheme.
  2  cbc:RoundingAmount [0..1]    The rounding amount (positive or negative) added to the calculated tax total to produce the rounded TaxAmount.
  3  cbc:TaxEvidenceIndicator [0..1]    An indicator that this total is recognized as legal evidence for taxation purposes (true) or not (false).
  4  cbc:TaxIncludedIndicator [0..1]    An indicator that tax is included in the calculation (true) or not (false).
  5  cac:TaxSubtotal [0..*]    One of the subtotals the sum of which equals the total tax amount for a particular taxation scheme.

*/
var ParamsMap = {
    taxAmount: { order: 1, attributeName: 'cbc:TaxAmount', min: 1, max: 1, classRef: UdtAmount_1.UdtAmount },
    roundingAmount: { order: 2, attributeName: 'cbc:RoundingAmount', min: 0, max: 1, classRef: UdtAmount_1.UdtAmount },
    taxEvidenceIndicator: { order: 3, attributeName: 'cbc:TaxEvidenceIndicator', min: 0, max: 1, classRef: UnqualifiedDataTypes_1.UdtIndicator },
    taxIncludedIndicator: { order: 4, attributeName: 'cac:TaxIncludedIndicator', min: 0, max: 1, classRef: UnqualifiedDataTypes_1.UdtIndicator },
    taxSubtotals: { order: 5, attributeName: 'cac:TaxSubtotal', min: 0, max: undefined, classRef: TaxSubtotal_1.TaxSubtotal },
};
/**
 *
 */
var TaxTotalType = /** @class */ (function (_super) {
    __extends(TaxTotalType, _super);
    /**
     * @param {AllowedParams} content
     * @param {string} name
     */
    function TaxTotalType(content) {
        return _super.call(this, content, ParamsMap, 'cac:TaxTotalType') || this;
    }
    /**
     *
     * @param { UdtAmount | string } value
     */
    TaxTotalType.prototype.setTaxAmount = function (value) {
        this.attributes.taxAmount = value instanceof UdtAmount_1.UdtAmount ? value : new UdtAmount_1.UdtAmount(value);
    };
    /**
     *
     * @param {boolean} raw raw value
     */
    TaxTotalType.prototype.getTaxAmount = function (raw) {
        if (raw === void 0) { raw = true; }
        return raw ? this.attributes.taxAmount.content : this.attributes.taxAmount;
    };
    TaxTotalType.prototype.getTaxSubtotals = function () {
        return this.attributes.taxSubtotals;
    };
    TaxTotalType.prototype.setTaxSubtotals = function (taxSubtotals) {
        if (!Array.isArray(taxSubtotals))
            throw new Error('taxSubtotals must to be an Array');
        taxSubtotals.forEach(function (value) {
            if (!(value instanceof TaxSubtotal_1.TaxSubtotal)) {
                throw new Error('Items of taxSubtotals must be instance of TaxSubtotal class');
            }
        });
        this.attributes.taxSubtotals = taxSubtotals;
    };
    TaxTotalType.prototype.calculateTotalTaxAmount = function () {
        return this.attributes.taxSubtotals.reduce(function (acc, current) {
            return acc + current.getTaxAmount();
        }, 0);
    };
    return TaxTotalType;
}(GenericAggregateComponent_1.default));
exports.TaxTotal = TaxTotalType;
exports.WithholdingTaxTotal = TaxTotalType;
